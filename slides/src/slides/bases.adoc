== Project structure

[fragment]#Gradle build with Kotlin DSL#

[fragment]#Separated kotlin/java#

[NOTE.speaker]
--
Just a first example of what can be done with Kotlin

Separated for easiest management but can be mixed
--

== Functions first-class citizen

[fragment]#stored in variables#

[fragment]#stored in data structures#

[fragment]#passed as arguments#

[fragment]#returned from functions#

[fragment]#don't need classes#

== Top-level functions

[source, kotlin]
----
fun              {
  
}
----

[NOTE.speaker]
--
We start with fun

--

[transition=fade]
== Top-level functions

[source, kotlin]
----
fun main()       {
  
}
----

[NOTE.speaker]
--
Args are optionnal, println for system out println
--

[transition=fade]
== Top-level functions

[source, kotlin]
----
fun main(): Unit {
  
}
----

[NOTE.speaker]
--
Return type Unit like void in java

It's optional to specify it for functions
--

== Unit digression

Unit is an object

Unit.toString()

== Top-level functions

[source, kotlin]
----
fun main() : Unit {
    println("hello world")
}
----

[NOTE.speaker]
--
semicolon optionals

Create your first kotlin hello world
--

== Your turn

[source, kotlin]
----
fun main() {
    println("hello world")
}
----

Create your first kotlin hello world

== Variables

[source, java]
----
String pony = "Pinkie";
----

[source, hideCode]
----
    .
----

== Variables

[source, java]
----
String pony = "Pinkie";
----

[source, kotlin]
----
var 
----

== Variables

[source, java]
----
String pony = "Pinkie";
----

[source, kotlin]
----
var pony
----

== Variables

[source, java]
----
String pony = "Pinkie";
----

[source, kotlin]
----
var pony: String = "Pinkie"
----

== Variables

[source, java]
----
String pony = "Pinkie";
----

[source, kotlin]
----
var pony = "Pinkie"
----

[NOTE.speaker]
--
type inferred
--

== Variables

[source, java]
----
final String pony = "Pinkie";
----

[source, hideCode]
----
val pony = "Pinkie"
----

== Values

[source, java]
----
final String pony = "Pinkie";
----

[source, kotlin]
----
val pony = "Pinkie"
----

== Your turn

Update the main for printing

"hello " + variable

== Review

[source, kotlin]
----
fun main() {
    val pony = "Pinkie"
    println("hello " + pony)
}
----

== String template

[source, kotlin]
----
fun main() {
    val pony = "Pinkie"
    println("hello $pony")
}
----

== String template

[source, kotlin]
----
fun main() {
    val pony = "Pinkie"
    println("hello ${pony.toUpperCase()}")
}
----

[NOTE.speaker]
--
surround with brace for calling complex
--

== Null     

[source, kotlin]
----
val nullable : String = null
----

[NOTE.speaker]
--
Do you try this? Compiler issue
--

== Null safty

[source, kotlin]
----
val nullable : String? = null
----

== Null safty

[source, kotlin]
----
nullable.toUpperCase() // KO
----

[source, hideCode]
----
.
----

[source, hideCode]
----
.
----

[source, hideCode]
----
.
----

[NOTE.speaker]
--
How do we access a nullable ?
--

== Null safty

[source, kotlin]
----
if (null != nullable) nullable.toUpperCase()
----

[source, hideCode]
----
.
----

[source, hideCode]
----
.
----

[source, hideCode]
----
.
----

[NOTE.speaker]
--
Like optional in java, 
we know not null because tested
--

== Null safty

[source, kotlin]
----
if (null != nullable) nullable.toUpperCase()
----

[source, kotlin]
----
nullable?.toUpperCase()
----

[source, hideCode]
----
.
----

[source, hideCode]
----
.
----

[NOTE.speaker]
--
Same thing but simplified
--

== Null safty

[source, kotlin]
----
if (null != nullable) nullable.toUpperCase()
----

[source, kotlin]
----
nullable?.toUpperCase()
----

[source, kotlin]
----
nullable?.toUpperCase() ?: ""
----

[source, hideCode]
----
.
----

[NOTE.speaker]
--
Elvis operator for else null
--


== Null safty

[source, kotlin]
----
if (null != nullable) nullable.toUpperCase()
----

[source, kotlin]
----
nullable?.toUpperCase()
----

[source, kotlin]
----
nullable?.toUpperCase() ?: ""
----

[source, kotlin]
----
nullable!!.toUpperCase()
----

[NOTE.speaker]
--
From java but know it's not null?
In any case we know it can be null and we make a choice
--

== Class
[source, hideCode]
----
.



.
----

== Class

[source, kotlin]
----
class Pony {
    var name: String? = null


}
----

== Class

[source, kotlin]
----
class Pony {
    var name: String? = null
      get() { return field }
      set(value) { field = value }
}
----


== Class

[source, kotlin]
----
class Pony {
    var name: String? = null

    var friendsCount: Int = 1
}
----


== Constructor
[source, kotlin]
----
class Pony {
    var name: String
    var friendsCount: Int





}
----

== Constructor
[source, kotlin]
----
class Pony {
    var name: String
    var friendsCount: Int

    constructor(name: String, friendsCount: Int = 0){
        this.name = name
        this.friendsCount = friendsCount
    }
}
----

== Constructor

[source, kotlin]
----
class Pony(name: String, friendsCount: Int = 0) {
    var name: String = name
    var friendsCount = friendsCount





}
----

[NOTE.speaker]
--
friendsCount with default value see it later
--
== Constructor

[source, kotlin]
----
class Pony(val name: String,
           var friendsCount: Int = 0) {






}
----

== Calling constructor

[source, kotlin]
----
val pony = Pony("Rainbow", 3)
----

[NOTE.speaker]
--
no need of new
--

== Properties access

[source, kotlin]
----
val pony = Pony("Rainbow", 3)
pony.friendsCount = pony.name.length
----

cr√©er des getter setter

[NOTE.speaker]
--
useless but example of get and set
--

== POKO

[source, kotlin]
----
class Pony(val name: String) {

    override fun toString(): String { return name }
}
----

== Data class
----
data class Pony(val name: String)
----


[NOTE.speaker]
--
Free equals, hashcode, toString but also copy 
--

== Your turn

Create your own data class and replace your hello world variable

tips : class can be created in the same file or in a dedicated one